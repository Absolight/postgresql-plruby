#include "convcommon.h"

#include <utils/date.h>
#include <utils/nabstime.h>
#include <utils/timestamp.h>

static Timestamp epoch;
static ID	id_at,
		id_to_f,
		id_to_i,
		id_usec;

static VALUE
pl_fixnum_s_datum(VALUE obj, VALUE a)
{
    Oid typoid;
    Datum value;

    value = plruby_datum_get(a, &typoid);
    switch (typoid) {
    case OIDOID:
	return INT2NUM(DatumGetObjectId(value));
	break;
    case INT2OID:
	return INT2NUM(DatumGetInt16(value));
	break;
    case INT4OID:
	return INT2NUM(DatumGetInt32(value));
	break;
    case INT8OID:
	return INT2NUM(DatumGetInt64(value));
	break;
    default:
	rb_raise(rb_eArgError, "unknown OID type %d", typoid);
    }
    return Qnil;
}

static VALUE
pl_fixnum_to_datum(VALUE obj, VALUE a)
{
    int typoid, typlen;
    int value;
    Datum d;

    value = NUM2INT(obj);
    typoid = plruby_datum_oid(a, &typlen);
    switch (typoid) {
    case OIDOID:
    case INT2OID:
    case INT4OID:
	break;
    default:
	return Qnil;
    }
    if (typlen == 2) {
	d = Int16GetDatum(value);
    }
    else {
	d = Int32GetDatum(value);
    }
    return plruby_datum_set(a, d);
}

static VALUE
pl_float_s_datum(VALUE obj, VALUE a)
{
    Oid typoid;
    Datum value;

    value = plruby_datum_get(a, &typoid);
    switch (typoid) {
    case FLOAT4OID:
	return rb_float_new(DatumGetFloat4(value));
	break;

    case FLOAT8OID:
	return rb_float_new(DatumGetFloat8(value));
	break;

    case CASHOID:
    case NUMERICOID:
	return rb_float_new(DatumGetFloat8(plruby_dfc1(numeric_float8, value)));
	break;
    default:
	rb_raise(rb_eArgError, "unknown OID type %d", typoid);
    }
    return Qnil;
}

static VALUE
pl_float_to_datum(VALUE obj, VALUE a)
{
    int typoid, typlen;
    double value;
    Datum d;

    typoid = plruby_datum_oid(a, &typlen);
    switch (typoid) {
    case FLOAT4OID:
    case FLOAT8OID:
    case CASHOID:
    case NUMERICOID:
	break;
    default:
	return Qnil;
    }
    if (typlen == 4) {
	d = Float4GetDatum((float4)RFLOAT(obj)->value);
    }
    else {
	d = Float8GetDatum((float8)RFLOAT(obj)->value);
    }
    return plruby_datum_set(a, d);
}

static VALUE
pl_time_s_datum(VALUE klass, VALUE a)
{
    Timestamp	ts;
    Oid		typoid;
    Datum	value;

    /*
     * INTERVAL and RELTIME are converted to Float (number of seconds).
     * For INTERVALs containing nonzero month/year component, duration of one
     * month is assumed to be 30*24*60*60 seconds.  A special type has to be
     * created for this, because of the months/year components and also because
     * long or short enough numbers do not convert back right (exponential
     * notation of INTERVALs is not accepted by Postgres).
     *
     * TIMESTAMP, TIMESTAMP WITH TIME ZONE, ABSTIME, DATE are converted to klass
     * (Time), naturally.
     *
     * TIME and TIME WITH TIME ZONE are also converted to klass (Time), as in
     * the (totally broken anyway) 0.4.3 implementation.  The result is that
     * specific time since Unix epoch.  That makes little sense (the reverse
     * conversion of the result breaks anyway), but some at least.  A special
     * type has to be created for this.
     */
    value = plruby_datum_get(a, &typoid);
    switch (typoid) {
	/* Time interval types. */

    case RELTIMEOID:
	value = plruby_dfc1(reltime_interval, value);
	/* ... */
    case INTERVALOID:
	{
	    Interval *iv = DatumGetIntervalP(value);

	    return rb_float_new((double) iv->month * 30*24*60*60 + 
		    iv->time
#ifdef HAVE_INT64_TIMESTAMP
		    / 1E6
#endif
		);
	}

	/*
	 * Time of day types.
	 *
	 * No separate conversion code is written, abusing the coincidence of C
	 * types used for TimeADT and Timestamp (int64 or double, depending on
	 * HAVE_INT64_TIMESTAMP).  The proper implementation would use a special
	 * type anyway, see above.
	 */

    case TIMETZOID:
	{
	    TimeTzADT *timetz = DatumGetTimeTzADTP(value);

	    /* Shift according to the timezone. */
	    ts = timetz->time + (Timestamp) timetz->zone
#ifdef HAVE_INT64_TIMESTAMP
		* 1000000
#endif
		;
	}
	goto convert;

    case TIMEOID:
	ts = (Timestamp) DatumGetTimeADT(value);
	goto convert;

	/* The rest of types end up as a Timestamp in `value'. */

    case ABSTIMEOID:
	value = plruby_dfc1(abstime_timestamptz, value);
	break;

    case DATEOID:
	value = plruby_dfc1(date_timestamptz, value);
	break;

    case TIMESTAMPOID:
    case TIMESTAMPTZOID:
	break;

    default:
	rb_raise(rb_eTypeError, "%s: incompatible type OID %u",
		rb_class2name(klass), typoid);
    }

    ts = DatumGetTimestamp(value) - epoch;

convert:
    return rb_funcall(klass, id_at,
#ifndef HAVE_INT64_TIMESTAMP
	    1, rb_float_new(ts)
#else
	    2, LONG2NUM(ts / 1000000), ULONG2NUM(ts % 1000000)
#endif
	);
}

static VALUE
pl_time_to_datum(VALUE obj, VALUE a)
{
    PGFunction	conv;
    Datum	d;
    int		typoid;

    /* Conversion to only those Postgres types that end up as Time in
     * pl_time_s_datum() above is performed. */
    typoid = plruby_datum_oid(a, NULL);

    switch (typoid) {
    case ABSTIMEOID:
    case DATEOID:
    case TIMEOID:
    case TIMESTAMPOID:
    case TIMESTAMPTZOID:
    case TIMETZOID:
	break;

    default:
	return Qnil;
    }

    /* Convert Time to TimestampTz first. */
    d = TimestampTzGetDatum(epoch +
#ifndef HAVE_INT64_TIMESTAMP
	    NUM2DBL(rb_funcall(obj, id_to_f, 0))
#else
	    (TimestampTz) NUM2LONG(rb_funcall(obj, id_to_i, 0)) * 1000000 +
	    NUM2ULONG(rb_funcall(obj, id_usec, 0))
#endif
	    );

    conv = NULL;

    /* Now select the conversion function. */
    switch (typoid) {
    case ABSTIMEOID:
	conv = timestamptz_abstime;
	break;

    case DATEOID:
	conv = timestamptz_date;
	break;

    case TIMEOID:
	conv = timestamptz_time;
	break;

    case TIMESTAMPOID:
	conv = timestamptz_timestamp;
	break;

    case TIMESTAMPTZOID:
	break;

    case TIMETZOID:
	conv = timestamptz_timetz;
	break;

    default:
	/* Should be dead code as falling back to Qnil is above. */
	rb_raise(rb_eTypeError, "%s: incompatible type OID %u",
		rb_obj_classname(obj), typoid);
    }

    if (conv != NULL)
	d = plruby_dfc1(timestamptz_timestamp, d);

    return plruby_datum_set(a, d);
}

void Init_plruby_basic()
{
    epoch = SetEpochTimestamp();
    id_at = rb_intern("at");
    id_to_f = rb_intern("to_f");
    id_to_i = rb_intern("to_i");
    id_usec = rb_intern("usec");

    rb_define_singleton_method(rb_cFixnum, "from_datum", pl_fixnum_s_datum, 1);
    rb_define_method(rb_cFixnum, "to_datum", pl_fixnum_to_datum, 1);
    rb_define_singleton_method(rb_cFloat, "from_datum", pl_float_s_datum, 1);
    rb_define_method(rb_cFloat, "to_datum", pl_float_to_datum, 1);
    rb_define_singleton_method(rb_cTime, "from_datum", pl_time_s_datum, 1);
    rb_define_method(rb_cTime, "to_datum", pl_time_to_datum, 1);
}
