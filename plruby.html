<?xml version="1.0" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>plruby.rd</title>
</head>
<body>
<h1><a name="label:0" id="label:0">PL/Ruby</a></h1><!-- RDLabel: "PL/Ruby" -->
<ul>
<li><a href="#label:2">Defining function in PL Ruby</a></li>
<li><a href="#label:3">Function returning SET</a></li>
<li><a href="#label:4">Trigger procedures in PL Ruby</a></li>
<li><a href="#label:16">plruby_singleton_methods</a></li>
<li><a href="#label:17">Class and modules</a></li>
</ul>
<p>PL/Ruby is a loadable procedural language for the Postgres database
system  that enable the Ruby language to create functions and trigger
procedures</p>
<p>Functions and triggers are singleton methods of the module PLtemp.</p>
<h1><a name="label:1" id="label:1">WARNING</a></h1><!-- RDLabel: "WARNING" -->
<p><em>All arguments (to the function or the triggers) are passed as string 
values, except for NULL values represented by <kbd>Qnil</kbd>.</em>
<em>You must explicitely call a conversion function (like to_i) if you want 
to use an argument as an integer</em></p>
<h2><a name="label:2" id="label:2">Defining function in PL Ruby</a></h2><!-- RDLabel: "Defining function in PL Ruby" -->
<p>To create a function in the PL/Ruby language use the syntax</p>
<pre>CREATE FUNCTION funcname(arguments_type) RETURNS type AS '

 # PL/Ruby function body

' LANGUAGE 'plruby';</pre>
<p>when calling the function in a query, the arguments are given <em>as
string values</em> in the array <kbd>args</kbd>. To create a little max
function returning the higher of two int4 values write :</p>
<pre>CREATE FUNCTION ruby_max(int4, int4) RETURNS int4 AS '
    if args[0].to_i &gt; args[1].to_i
        return args[0]
    else
        return args[1]
    end
' LANGUAGE 'plruby';</pre>
<p>Tuple arguments are given as hash. Here is an example that defines
the overpaid_2 function (as found in the older Postgres documentation)
in PL/Ruby.</p>
<pre>CREATE FUNCTION overpaid_2 (EMP) RETURNS bool AS '
    args[0]["salary"].to_f &gt; 200000 || 
       (args[0]["salary"].to_f &gt; 100000 &amp;&amp; args[0]["age"].to_i &lt; 30)
' LANGUAGE 'plruby';</pre>
<h2><a name="label:3" id="label:3">Function returning SET</a></h2><!-- RDLabel: "Function returning SET" -->
<p>The return type must be declared as SETOF</p>
<p>The function must call <kbd>yield</kbd> to return rows or return a String which
must be a valid SELECT statement</p>
<p>For example to concatenate 2 rows create the function</p>
<pre>plruby_test=# CREATE FUNCTION tu(varchar) RETURNS setof record
plruby_test-# AS '
plruby_test'#    size = PLruby.column_name(args[0]).size
plruby_test'#    res = nil
plruby_test'#    PLruby.prepare("select * from #{args[0]}", 
plruby_test'#                   "block" =&gt; 50, "tmp" =&gt; true).each do |row|
plruby_test'#       if res.nil?
plruby_test'#          res = row.values
plruby_test'#       else
plruby_test'#          res.concat row.values
plruby_test'#          yield res
plruby_test'#          res = nil
plruby_test'#       end
plruby_test'#    end
plruby_test'#    if res
plruby_test'#       res.concat Array.new(size)
plruby_test'#       yield res
plruby_test'#    end
plruby_test'# ' language 'plruby';
CREATE FUNCTION
plruby_test=# 
plruby_test=# select * from tt;
 a | b  
---+----
 1 |  2
 3 |  4
 5 |  6
 7 |  8
 9 | 10
(5 rows)

plruby_test=# select * from tu('tt') as tbl(a int, b int, c int, d int);
 a | b  | c | d 
---+----+---+---
 1 |  2 | 3 | 4
 5 |  6 | 7 | 8
 9 | 10 |   |  
(3 rows)

plruby_test=# </pre>
<h2><a name="label:4" id="label:4">Trigger procedures in PL Ruby</a></h2><!-- RDLabel: "Trigger procedures in PL Ruby" -->
<p>Trigger procedures are defined in Postgres as functions without
arguments and a return type of opaque. In PL/Ruby the procedure is
called with 4 arguments :</p>
<dl>
<dt><a name="label:5" id="label:5">new (hash, tainted)
</a></dt><!-- RDLabel: "new (hash, tainted)
" -->
<dd>
<p>an hash containing the values of the new table row on INSERT/UPDATE
actions, or empty on DELETE. </p>
</dd>
<dt><a name="label:6" id="label:6">old (hash, tainted)
</a></dt><!-- RDLabel: "old (hash, tainted)
" -->
<dd>
<p>an hash containing the values of the old table row on UPDATE/DELETE
actions, or empty on INSERT </p>
</dd>
<dt><a name="label:7" id="label:7">args (array, tainted, frozen)
</a></dt><!-- RDLabel: "args (array, tainted, frozen)
" -->
<dd>
<p>An array of the arguments to the procedure as given in the CREATE
TRIGGER statement </p>
</dd>
<dt><a name="label:8" id="label:8">tg (hash, tainted, frozen)
</a></dt><!-- RDLabel: "tg (hash, tainted, frozen)
" -->
<dd>
<p>The following keys are defined</p>
<dl>
<dt><a name="label:9" id="label:9">name
</a></dt><!-- RDLabel: "name
" -->
<dd>
<p>The name of the trigger from the CREATE TRIGGER statement.</p>
</dd>
<dt><a name="label:10" id="label:10">relname
</a></dt><!-- RDLabel: "relname
" -->
<dd>
<p>The name of the relation who has fired the trigger</p>
</dd>
<dt><a name="label:11" id="label:11">relid
</a></dt><!-- RDLabel: "relid
" -->
<dd>
<p>The object ID of the table that caused the trigger procedure to be invoked.</p>
</dd>
<dt><a name="label:12" id="label:12">relatts
</a></dt><!-- RDLabel: "relatts
" -->
<dd>
<p>An array containing the name of the tables field.</p>
</dd>
<dt><a name="label:13" id="label:13">when
</a></dt><!-- RDLabel: "when
" -->
<dd>
<p>The constant <kbd>PLruby::BEFORE</kbd>, <kbd>PLruby::AFTER</kbd> or
<kbd>PLruby::UNKNOWN</kbd> depending on the event of the trigger call.</p>
</dd>
<dt><a name="label:14" id="label:14">level
</a></dt><!-- RDLabel: "level
" -->
<dd>
<p>The constant <kbd>PLruby::ROW</kbd> or <kbd>PLruby::STATEMENT</kbd>
depending on the event of the trigger call.</p>
</dd>
<dt><a name="label:15" id="label:15">op
</a></dt><!-- RDLabel: "op
" -->
<dd>
<p>The constant <kbd>PLruby::INSERT</kbd>, <kbd>PLruby::UPDATE</kbd> or 
<kbd>PLruby::DELETE</kbd> depending on the event of the trigger call.</p>
</dd>
</dl>
</dd>
</dl>
<p>The return value from a trigger procedure is one of the constant
<kbd>PLruby::OK</kbd> or <kbd>PLruby::SKIP</kbd>, or an hash. If the
return value is <kbd>PLruby::OK</kbd>, the normal operation
(INSERT/UPDATE/DELETE) that fired this trigger will take
place. Obviously, <kbd>PLruby::SKIP</kbd> tells the trigger manager to
silently suppress the operation. The hash tells
PL/Ruby to return a modified row to the trigger manager that will be
inserted instead of the one given in <kbd>new</kbd> (INSERT/UPDATE
only). Needless to say that all this is only meaningful when the
trigger is BEFORE and FOR EACH ROW.</p>
<p>Here's a little example trigger procedure that forces an integer
value in a table to keep track of the # of updates that are performed
on the row. For new row's inserted, the value is initialized to 0 and
then incremented on every update operation :</p>
<pre>CREATE FUNCTION trigfunc_modcount() RETURNS OPAQUE AS '
    case tg["op"]
    when PLruby::INSERT
        new[args[0]] = 0
      when PLruby::UPDATE
          new[args[0]] = old[args[0]].to_i + 1
      else
          return PLruby::OK
      end
      new
  ' LANGUAGE 'plruby';

  CREATE TABLE mytab (num int4, modcnt int4, descr text);

  CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
      FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');</pre>
<p>A more complex example (extract from test_setup.sql in the distribution)
which use the global variable <kbd>$Plans</kbd> to store a prepared
plan</p>
<pre>create function trig_pkey2_after() returns opaque as '
   if ! $Plans.key?("plan_dta2_upd")
       $Plans["plan_dta2_upd"] = 
            PLruby.prepare("update T_dta2 
                            set ref1 = $3, ref2 = $4
                            where ref1 = $1 and ref2 = $2",
                           ["int4", "varchar", "int4", "varchar" ])
       $Plans["plan_dta2_del"] = 
            PLruby.prepare("delete from T_dta2 
                            where ref1 = $1 and ref2 = $2", 
                           ["int4", "varchar"])
   end

   old_ref_follow = false
   old_ref_delete = false

   case tg["op"]
   when PLruby::UPDATE
       new["key2"] = new["key2"].upcase
       old_ref_follow = (new["key1"] != old["key1"]) || 
                        (new["key2"] != old["key2"])
   when PLruby::DELETE
       old_ref_delete = true
   end

   if old_ref_follow
       n = $Plans["plan_dta2_upd"].exec([old["key1"], old["key2"], new["key1"],
new["key2"]])
       warn "updated #{n} entries in T_dta2 for new key in T_pkey2" if n != 0
   end

   if old_ref_delete
       n = $Plans["plan_dta2_del"].exec([old["key1"], old["key2"]])
       warn "deleted #{n} entries from T_dta2" if n != 0
   end

   PLruby::OK
' language 'plruby';

create trigger pkey2_after after update or delete on T_pkey2
 for each row execute procedure
 trig_pkey2_after();</pre>
<h2><a name="label:16" id="label:16">plruby_singleton_methods</a></h2><!-- RDLabel: "plruby_singleton_methods" -->
<p>Sometime it can be usefull to define methods (in pure Ruby) which can be
called from a PL/Ruby function or a PL/Ruby trigger.</p>
<p>In this case, you have 2 possibilities</p>
<ul>
<li>the "stupid" way <code>:-) :-) :-)</code></li>
</ul>
<p>just close the current definition of the function (or trigger) with a
<code>end</code> and define your singleton method without the final <code>end</code></p>
<p>Here a small and useless example</p>
<pre>toto=&gt; CREATE FUNCTION tutu() RETURNS int4 AS '
toto'&gt;     toto(1, 3) + toto(4, 4)
toto'&gt; end
toto'&gt; 
toto'&gt; def PLtemp.toto(a, b)
toto'&gt;     a + b
toto'&gt; ' LANGUAGE 'plruby';
CREATE
toto=&gt; select tutu();
tutu
----
  12
(1 row)

toto=&gt;</pre>
<ul>
<li>create a table plruby_singleton_methods with the columns (name, args, body)</li>
</ul>
<p>At load time, PL/Ruby look if it exist a table plruby_singleton_methods and if
found try, for each row, to define singleton methods with the template :</p>
<pre>def PLtemp.#{name} (#{args})
    #{body}
end</pre>
<p>The previous example can be written (you have a more complete example in ???)</p>
<pre>toto=&gt; SELECT * FROM plruby_singleton_methods;
name|args|body 
----+----+-----
toto|a, b|a + b
(1 row)

toto=&gt; CREATE FUNCTION tutu() RETURNS int4 AS '
toto'&gt;     toto(1, 3) + toto(4, 4)
toto'&gt; ' LANGUAGE 'plruby';
CREATE
toto=&gt; select tutu();
tutu
----
  12
(1 row)

toto=&gt;</pre>
<h2><a name="label:17" id="label:17">Class and modules</a></h2><!-- RDLabel: "Class and modules" -->
<h3><a name="label:18" id="label:18">Global</a></h3><!-- RDLabel: "Global" -->
<dl>
<dt><a name="label:19" id="label:19"><code>warn [<var>level</var>], <var>message</var></code></a></dt><!-- RDLabel: "warn [level], message" -->
<dd>
<p>Ruby interface to PostgreSQL elog()</p>
<p>Possible value for <kbd>level</kbd> are <kbd>NOTICE</kbd>, <kbd>DEBUG</kbd> and <kbd>NOIND</kbd></p>
<p>Use <kbd>raise()</kbd> if you want to simulate <kbd>elog(ERROR, "...")</kbd></p></dd>
<dt><a name="label:20" id="label:20"><code>$Plans (<var>hash</var>, <var>tainted</var>)</code></a></dt><!-- RDLabel: "$Plans" -->
<dd>
<p>can be used to store prepared plans.</p></dd>
</dl>
<h3><a name="label:21" id="label:21">module PLruby</a></h3><!-- RDLabel: "module PLruby" -->
<dl>
<dt><a name="label:22" id="label:22"><code>column_name(<var>table</var>)</code></a></dt><!-- RDLabel: "column_name" -->
<dd>
<p>Return the name of the columns for the table</p></dd>
<dt><a name="label:23" id="label:23"><code>column_type(<var>table</var>)</code></a></dt><!-- RDLabel: "column_type" -->
<dd>
<p>return the type of the columns for the table</p></dd>
<dt><a name="label:24" id="label:24"><code>result_name</code></a></dt><!-- RDLabel: "result_name" -->
<dd>
<p>Return the name of the columns for a function returning a SETOF</p></dd>
<dt><a name="label:25" id="label:25"><code>result_type</code></a></dt><!-- RDLabel: "result_type" -->
<dd>
<p>Return the type of the columns for a function returning a SETOF</p></dd>
<dt><a name="label:26" id="label:26"><code>result_size</code></a></dt><!-- RDLabel: "result_size" -->
<dd>
<p>Return the number of columns  for a function returning a SETOF</p></dd>
<dt><a name="label:27" id="label:27"><code>quote(<var>string</var>)</code></a></dt><!-- RDLabel: "quote" -->
<dd>
<p>Duplicates all occurences of single quote and backslash
characters. It should be used when variables are used in the query
string given to spi_exec or spi_prepare (not for the value list on
execp).</p></dd>
<dt><a name="label:28" id="label:28"><code>exec(<var>string</var> [, <var>count</var> [, <var>type</var>]])</code></a><!-- RDLabel: "exec" -->
<dt><a name="label:29" id="label:29"><code>spi_exec(<var>string</var> [, <var>count</var> [, <var>type</var>]])</code></a></dt><!-- RDLabel: "spi_exec" -->
<dd>
<p>Call parser/planner/optimizer/executor for query. The optional
<kbd>count</kbd> value tells spi_exec the maximum number of rows to be
processed by the query.</p>
<dl>
<dt><a name="label:30" id="label:30">SELECT
</a></dt><!-- RDLabel: "SELECT
" -->
<dd>
<p>If the query is a SELECT statement, an array is return (if count is
not specified or with a value &gt; 1). Each element of this array is an
hash where the key is the column name.  For example this procedure
display all rows in the table pg_table.</p>
<pre>CREATE FUNCTION pg_table_dis() RETURNS int4 AS '
res = PLruby.exec("select * from pg_class")
res.each do |x|
    warn "======================"
    x.each do |y, z|
        warn "name = #{y} -- value = #{z}"
    end
    warn "======================"
end
return res.size
' LANGUAGE 'plruby';</pre>
<p>if type is specified it can take the value</p>
<ul>
<li>"array" return an array with the element ["name", "value", "type", "len", "typeid"]</li>
<li>"hash" return an hash with the keys {"name", "value", "type", "len", "typeid"}</li>
</ul>
<pre>Example :

create table T_pkey1 (
    skey1        int4,
    skey2        varchar(20),
    stxt         varchar(40)
);

create function toto() returns bool as '
   warn("=======")
   PLruby.exec("select * from T_pkey1", 1, "hash") do |a|
      warn(a.inspect)
   end
   warn("=======")
   PLruby.exec("select * from T_pkey1", 1, "array") do |a|
      warn(a.inspect)
   end
   warn("=======")
   PLruby.exec("select * from T_pkey1", 1) do |a|
      warn(a.inspect)
   end
   warn("=======")
   return true
' language 'plruby';


plruby_test=# select toto();
NOTICE:  =======
NOTICE:  {"name"=&gt;"skey1", "typeid"=&gt;23, "type"=&gt;"int4", "value"=&gt;"12", "len"=&gt;4}
NOTICE:  {"name"=&gt;"skey2", "typeid"=&gt;1043, "type"=&gt;"varchar", "value"=&gt;"a", "len"=&gt;20}
NOTICE:  {"name"=&gt;"stxt", "typeid"=&gt;1043, "type"=&gt;"varchar", "value"=&gt;"b", "len"=&gt;40}
NOTICE:  =======
NOTICE:  ["skey1", "12", "int4", 4, 23]
NOTICE:  ["skey2", "a", "varchar", 20, 1043]
NOTICE:  ["stxt", "b", "varchar", 40, 1043]
NOTICE:  =======
NOTICE:  ["skey1", "12"]
NOTICE:  ["skey2", "a"]
NOTICE:  ["stxt", "b"]
NOTICE:  =======
 toto 
------
 t
(1 row)

plruby_test=# </pre>
<p>A block can be specified, in this case a call to yield() will be
made.</p>
<p>If count is specified with the value 1, only the first row (or
FALSE if it fail) is returned as a hash. Here a little example :</p>
<pre>CREATE FUNCTION pg_table_dis() RETURNS int4 AS '
   PLruby.exec("select * from pg_class", 1) { |y, z|
      warn "name = #{y} -- value = #{z}"
  }
  return 1
' LANGUAGE 'plruby';</pre>
</dd>
<dt><a name="label:31" id="label:31">SELECT INTO, INSERT, UPDATE, DELETE
</a></dt><!-- RDLabel: "SELECT INTO, INSERT, UPDATE, DELETE
" -->
<dd>
<p>return the number of rows insered, updated, deleted, ...</p>
</dd>
<dt><a name="label:32" id="label:32">UTILITY
</a></dt><!-- RDLabel: "UTILITY
" -->
<dd>
<p>return TRUE</p>
</dd>
</dl></dd>
<dt><a name="label:33" id="label:33"><code>prepare(<var>string</var>[, <var>types</var>])</code></a><!-- RDLabel: "prepare" -->
<dt><a name="label:34" id="label:34"><code>spi_prepare(<var>string</var>[, <var>types</var>])</code></a><!-- RDLabel: "spi_prepare" -->
<dt><a name="label:35" id="label:35"><code>prepare(<var>string</var>, "<var>types</var>" =&gt; <var>types</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>, "<var>tmp</var>" =&gt; <var>true</var>)</code></a></dt><!-- RDLabel: "prepare" -->
<dd>
<p>Prepares AND SAVES a query plan for later execution. It is a bit
different from the C level SPI_prepare in that the plan is
automatically copied to the toplevel memory context.</p>
<p>To create a plan without saving it, give it the option
<kbd>'tmp' =&gt; true</kbd></p>
<p>If the query references arguments, the type names must be given as a
Ruby array of strings. The return value from prepare is a
<kbd>PLrubyplan</kbd> object to be used in subsequent calls to
<kbd>PLrubyplan#exec</kbd>.</p>
<p>If the hash given has the keys <kbd>count</kbd>, <kbd>output</kbd> these values
will be given to the subsequent calls to <kbd>each</kbd></p></dd>
</dl>
<h3><a name="label:36" id="label:36">class PLrubyplan</a></h3><!-- RDLabel: "class PLrubyplan" -->
<dl>
<dt><a name="label:37" id="label:37"><code>exec(<var>values</var>, [<var>count</var> [, <var>type</var>]])</code></a><!-- RDLabel: "exec" -->
<dt><a name="label:38" id="label:38"><code>execp(<var>values</var>, [<var>count</var> [, <var>type</var>]])</code></a><!-- RDLabel: "execp" -->
<dt><a name="label:39" id="label:39"><code>exec("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>)</code></a><!-- RDLabel: "exec" -->
<dt><a name="label:40" id="label:40"><code>execp("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>)</code></a></dt><!-- RDLabel: "execp" -->
<dd>
<p>Execute a prepared plan from <kbd>PLruby#prepare</kbd> with variable
substitution. The optional <kbd>count</kbd> value tells
<kbd>PLrubyplan#exec</kbd> the maximum number of rows to be processed by the
query.</p>
<p>If there was a typelist given to <kbd>PLruby#prepare</kbd>, an array
of <kbd>values</kbd> of exactly the same length must be given to
<kbd>PLrubyplan#exec</kbd> as first argument. If the type list on
<kbd>PLruby#prepare</kbd> was empty, this argument must be omitted.</p>
<p>If the query is a SELECT statement, the same as described for
<kbd>PLruby#exec</kbd> happens for the loop-body and the variables for
the fields selected.</p>
<p>If type is specified it can take the values</p>
<ul>
<li>"array" return an array with the element ["name", "value", "type", "len", "typeid"]</li>
<li>"hash" return an hash with the keys {"name", "value", "type", "len", "typeid"}</li>
<li>"values" return an array with all values</li>
</ul>
<p>Here's an example for a PL/Ruby function using a prepared plan : </p>
<pre>CREATE FUNCTION t1_count(int4, int4) RETURNS int4 AS '
    if ! $Plans.key?("plan")
        # prepare the saved plan on the first call
        $Plans["plan"] = PLruby.prepare("SELECT count(*) AS cnt FROM t1 
                                          WHERE num &gt;= $1 AND num &lt;= $2",
                                         ["int4", "int4"])
    end
    n = $Plans["plan"].exec([args[0], args[1]], 1)
    n["cnt"]
' LANGUAGE 'plruby';</pre></dd>
<dt><a name="label:41" id="label:41"><code>each(<var>values</var>, [<var>count</var> [, <var>type</var> ]]) { ... }</code></a><!-- RDLabel: "each" -->
<dt><a name="label:42" id="label:42"><code>fetch(<var>values</var>, [<var>count</var> [, <var>type</var> ]]) { ... }</code></a><!-- RDLabel: "fetch" -->
<dt><a name="label:43" id="label:43"><code>each("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>) { ... }</code></a><!-- RDLabel: "each" -->
<dt><a name="label:44" id="label:44"><code>fetch("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>) { ... }</code></a></dt><!-- RDLabel: "fetch" -->
<dd>
<p>Same then #exec but a call to SPI_cursor_open(), SPI_cursor_fetch() is made.</p>
<p>Can be used only with a block and a SELECT statement</p>
<pre>create function toto() returns bool as '
       plan = PLruby.prepare("select * from T_pkey1")
       warn "=====&gt; ALL"
       plan.each do |x|
          warn(x.inspect)
       end
       warn "=====&gt; FIRST 2"
       plan.each("count" =&gt; 2) do |x|
          warn(x.inspect)
       end
       return true
' language 'plruby';

plruby_test=# select * from T_pkey1;
 skey1 | skey2 | stxt 
-------+-------+------
    12 | a     | b
    24 | c     | d
    36 | e     | f
(3 rows)

plruby_test=# 
plruby_test=# select toto();
NOTICE:  =====&gt; ALL
NOTICE:  {"skey1"=&gt;"12", "skey2"=&gt;"a", "stxt"=&gt;"b"}
NOTICE:  {"skey1"=&gt;"24", "skey2"=&gt;"c", "stxt"=&gt;"d"}
NOTICE:  {"skey1"=&gt;"36", "skey2"=&gt;"e", "stxt"=&gt;"f"}
NOTICE:  =====&gt; FIRST 2
NOTICE:  {"skey1"=&gt;"12", "skey2"=&gt;"a", "stxt"=&gt;"b"}
NOTICE:  {"skey1"=&gt;"24", "skey2"=&gt;"c", "stxt"=&gt;"d"}
 toto 
------
 t
(1 row)

plruby_test=# </pre></dd>
</dl>

</body>
</html>
