<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD><TITLE>plruby.rd</TITLE>
</HEAD>
<BODY>
<H1><A NAME="label:0">PL/Ruby</A></H1>
<UL>
<LI><P>
<A HREF="#label:2">Defining function in PL/Ruby</A>
</P>
<LI><P>
<A HREF="#label:3">Trigger procedures in PL/Ruby</A>
</P>
<LI><P>
<A HREF="#label:4">plruby_singleton_methods</A>
</P>
<LI><P>
<A HREF="#label:5">Class and modules</A>
</P>
</UL>
<P>
PL/Ruby is a loadable procedural language for the Postgres database
system  that enable the Ruby language to create functions and trigger
procedures
</P>
<P>
Functions and triggers are singleton methods of the module PLtemp.
</P>
<H1><A NAME="label:1">WARNING</A></H1>
<P>
<EM>All arguments (to the function or the triggers) are passed as string 
values, except for NULL values represented by <KBD>Qnil</KBD>.</EM>
<EM>You must explicitely call a conversion function (like to_i) if you want 
to use an argument as an integer</EM>
</P>
<H2><A NAME="label:2">Defining function in PL/Ruby</A></H2>
<P>
To create a function in the PL/Ruby language use the syntax
</P>
<BLOCKQUOTE><PRE>
CREATE FUNCTION funcname(arguments_type) RETURNS type AS '

 # PL/Ruby function body

' LANGUAGE 'plruby';

</PRE></BLOCKQUOTE>
<P>
when calling the function in a query, the arguments are given <EM>as
string values</EM> in the array <KBD>args</KBD>. To create a little max
function returning the higher of two int4 values write :
</P>
<BLOCKQUOTE><PRE>
CREATE FUNCTION ruby_max(int4, int4) RETURNS int4 AS '
    if args[0].to_i &gt; args[1].to_i
        return args[0]
    else
        return args[1]
    end
' LANGUAGE 'plruby';


</PRE></BLOCKQUOTE>
<P>
Tuple arguments are given as hash. Here is an example that defines
the overpaid_2 function (as found in the older Postgres documentation)
in PL/Ruby.
</P>
<BLOCKQUOTE><PRE>
CREATE FUNCTION overpaid_2 (EMP) RETURNS bool AS '
    args[0]["salary"].to_f &gt; 200000 || 
       (args[0]["salary"].to_f &gt; 100000 &amp;&amp; args[0]["age"].to_i &lt; 30)
' LANGUAGE 'plruby';


</PRE></BLOCKQUOTE>
<H2><A NAME="label:3">Trigger procedures in PL/Ruby</A></H2>
<P>
Trigger procedures are defined in Postgres as functions without
arguments and a return type of opaque. In PL/Ruby the procedure is
called with 4 arguments :
</P>
<DL>
<DT><A NAME="label:9">new (hash, tainted)</A>
<DD>
<P>
an hash containing the values of the new table row on INSERT/UPDATE
actions, or empty on DELETE. 
</P>
</DD>
<DT><A NAME="label:10">old (hash, tainted)</A>
<DD>
<P>
an hash containing the values of the old table row on UPDATE/DELETE
actions, or empty on INSERT 
</P>
</DD>
<DT><A NAME="label:11">args (array, tainted, frozen)</A>
<DD>
<P>
An array of the arguments to the procedure as given in the CREATE
TRIGGER statement 
</P>
</DD>
<DT><A NAME="label:12">tg (hash, tainted, frozen)</A>
<DD>
<P>
The following keys are defined
</P>

<DL>
<DT><A NAME="label:13">name</A>
<DD>
<P>
The name of the trigger from the CREATE TRIGGER statement.
</P>
</DD>
<DT><A NAME="label:14">relname</A>
<DD>
<P>
The name of the relation who has fired the trigger
</P>
</DD>
<DT><A NAME="label:15">relid</A>
<DD>
<P>
The object ID of the table that caused the trigger procedure to be invoked.
</P>
</DD>
<DT><A NAME="label:16">relatts</A>
<DD>
<P>
An array containing the name of the tables field.
</P>
</DD>
<DT><A NAME="label:17">when</A>
<DD>
<P>
The constant <KBD>PLruby::BEFORE</KBD>, <KBD>PLruby::AFTER</KBD> or
<KBD>PLruby::UNKNOWN</KBD> depending on the event of the trigger call.
</P>
</DD>
<DT><A NAME="label:18">level</A>
<DD>
<P>
The constant <KBD>PLruby::ROW</KBD> or <KBD>PLruby::STATEMENT</KBD>
depending on the event of the trigger call.
</P>
</DD>
<DT><A NAME="label:19">op</A>
<DD>
<P>
The constant <KBD>PLruby::INSERT</KBD>, <KBD>PLruby::UPDATE</KBD> or 
<KBD>PLruby::DELETE</KBD> depending on the event of the trigger call.
</P>
</DD>
</DL>
</DD>
</DL>
<P>
The return value from a trigger procedure is one of the constant
<KBD>PLruby::OK</KBD> or <KBD>PLruby::SKIP</KBD>, or an hash. If the
return value is <KBD>PLruby::OK</KBD>, the normal operation
(INSERT/UPDATE/DELETE) that fired this trigger will take
place. Obviously, <KBD>PLruby::SKIP</KBD> tells the trigger manager to
silently suppress the operation. The hash tells
PL/Ruby to return a modified row to the trigger manager that will be
inserted instead of the one given in <KBD>new</KBD> (INSERT/UPDATE
only). Needless to say that all this is only meaningful when the
trigger is BEFORE and FOR EACH ROW.
</P>
<P>
Here's a little example trigger procedure that forces an integer
value in a table to keep track of the # of updates that are performed
on the row. For new row's inserted, the value is initialized to 0 and
then incremented on every update operation :
</P>
<BLOCKQUOTE><PRE>
CREATE FUNCTION trigfunc_modcount() RETURNS OPAQUE AS '
    case tg["op"]
    when PLruby::INSERT
        new[args[0]] = 0
    when PLruby::UPDATE
        new[args[0]] = old[args[0]].to_i + 1
    else
        return PLruby::OK
    end
    new
' LANGUAGE 'plruby';

CREATE TABLE mytab (num int4, modcnt int4, descr text);

CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
    FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');



</PRE></BLOCKQUOTE>
<P>
A more complex example (extract from test_setup.sql in the distribution)
which use the global variable <KBD>$Plans</KBD> to store a prepared
plan
</P>
<BLOCKQUOTE><PRE>
create function trig_pkey2_after() returns opaque as '
   if ! $Plans.key?("plan_dta2_upd")
       $Plans["plan_dta2_upd"] = 
            PLruby.prepare("update T_dta2 
                            set ref1 = $3, ref2 = $4
                            where ref1 = $1 and ref2 = $2",
                           ["int4", "varchar", "int4", "varchar" ])
       $Plans["plan_dta2_del"] = 
            PLruby.prepare("delete from T_dta2 
                            where ref1 = $1 and ref2 = $2", 
                           ["int4", "varchar"])
   end

   old_ref_follow = false
   old_ref_delete = false

   case tg["op"]
   when PLruby::UPDATE
       new["key2"] = new["key2"].upcase
       old_ref_follow = (new["key1"] != old["key1"]) || 
                        (new["key2"] != old["key2"])
   when PLruby::DELETE
       old_ref_delete = true
   end

   if old_ref_follow
       n = $Plans["plan_dta2_upd"].exec([old["key1"], old["key2"], new["key1"],
new["key2"]])
       warn "updated #{n} entries in T_dta2 for new key in T_pkey2" if n != 0
   end

   if old_ref_delete
       n = $Plans["plan_dta2_del"].exec([old["key1"], old["key2"]])
       warn "deleted #{n} entries from T_dta2" if n != 0
   end

   PLruby::OK
' language 'plruby';

create trigger pkey2_after after update or delete on T_pkey2
 for each row execute procedure
 trig_pkey2_after();


</PRE></BLOCKQUOTE>
<H2><A NAME="label:4">plruby_singleton_methods</A></H2>
<P>
Sometime it can be usefull to define methods (in pure Ruby) which can be
called from a PL/Ruby function or a PL/Ruby trigger.
</P>
<P>
In this case, you have 2 possibilities
</P>
<UL>
<LI><P>
the "stupid" way <CODE>:-) :-) :-)</CODE>
</P>
</UL>
<P>
just close the current definition of the function (or trigger) with a
<CODE>end</CODE> and define your singleton method without the final <CODE>end</CODE>
</P>
<P>
Here a small and useless example
</P>
<BLOCKQUOTE><PRE>
toto=&gt; CREATE FUNCTION tutu() RETURNS int4 AS '
toto'&gt;     toto(1, 3) + toto(4, 4)
toto'&gt; end
toto'&gt; 
toto'&gt; def PLtemp.toto(a, b)
toto'&gt;     a + b
toto'&gt; ' LANGUAGE 'plruby';
CREATE
toto=&gt; select tutu();
tutu
----
  12
(1 row)

toto=&gt;


</PRE></BLOCKQUOTE>
<UL>
<LI><P>
create a table plruby_singleton_methods with the columns (name, args, body)
</P>
</UL>
<P>
At load time, PL/Ruby look if it exist a table plruby_singleton_methods and if
found try, for each row, to define singleton methods with the template :
</P>
<BLOCKQUOTE><PRE>
def PLtemp.#{name} (#{args})
    #{body}
end

</PRE></BLOCKQUOTE>
<P>
The previous example can be written (you have a more complete example in ???)
</P>
<BLOCKQUOTE><PRE>
toto=&gt; SELECT * FROM plruby_singleton_methods;
name|args|body 
----+----+-----
toto|a, b|a + b
(1 row)

toto=&gt; CREATE FUNCTION tutu() RETURNS int4 AS '
toto'&gt;     toto(1, 3) + toto(4, 4)
toto'&gt; ' LANGUAGE 'plruby';
CREATE
toto=&gt; select tutu();
tutu
----
  12
(1 row)

toto=&gt;


</PRE></BLOCKQUOTE>
<H2><A NAME="label:5">Class and modules</A></H2>
<H3><A NAME="label:6">Global</A></H3>
<DL>
<DT><A NAME="label:20">warn [level], message</A>
<DD>
<P>
Ruby interface to PostgreSQL elog()
</P>

<P>
Possible value for <KBD>level</KBD> are <KBD>NOTICE</KBD>, <KBD>DEBUG</KBD> and <KBD>NOIND</KBD>
</P>

<P>
Use <KBD>raise()</KBD> if you want to simulate <KBD>elog(ERROR, "...")</KBD>
</P>
</DD>
<DT><A NAME="label:21">$Plans (hash, tainted)</A>
<DD>
<P>
can be used to store prepared plans.
</P>
</DD>
</DL>
<H3><A NAME="label:7">module PLruby</A></H3>
<DL>
<DT><A NAME="label:22">quote string</A>
<DD>
<P>
Duplicates all occurences of single quote and backslash
characters. It should be used when variables are used in the query
string given to spi_exec or spi_prepare (not for the value list on
execp).
</P>
</DD>
<DT><A NAME="label:23">exec(string [, count])</A>
<DT><A NAME="label:24">spi_exec(string [, count])</A>
<DD>
<P>
Call parser/planner/optimizer/executor for query. The optional
<KBD>count</KBD> value tells spi_exec the maximum number of rows to be
processed by the query.
</P>

<DL>
<DT><A NAME="label:27">SELECT</A>
<DD>
<P>
If the query is a SELECT statement, an array is return (if count is
not specified or with a value &gt; 1). Each element of this array is an
hash where the key is the column name.  For example this procedure
display all rows in the table pg_table.
</P>

<BLOCKQUOTE><PRE>
CREATE FUNCTION pg_table_dis() RETURNS int4 AS '
res = PLruby.exec("select * from pg_class")
res.each do |x|
    warn "======================"
    x.each do |y, z|
        warn "name = #{y} -- value = #{z}"
    end
    warn "======================"
end
return res.size
' LANGUAGE 'plruby';

</PRE></BLOCKQUOTE>

<P>
A block can be specified, in this case a call to yield() will be
made.
</P>

<P>
If count is specified with the value 1, only the first row (or
FALSE if it fail) is returned as a hash. Here a little example :
</P>

<BLOCKQUOTE><PRE>
CREATE FUNCTION pg_table_dis() RETURNS int4 AS '
   PLruby.exec("select * from pg_class", 1) { |y, z|
      warn "name = #{y} -- value = #{z}"
  }
  return 1
' LANGUAGE 'plruby';

</PRE></BLOCKQUOTE>
</DD>
<DT><A NAME="label:28">SELECT INTO, INSERT, UPDATE, DELETE</A>
<DD>
<P>
return the number of rows insered, updated, deleted, ...
</P>
</DD>
<DT><A NAME="label:29">UTILITY</A>
<DD>
<P>
return TRUE
</P>
</DD>
</DL>
</DD>
<DT><A NAME="label:25">prepare(string, [array])</A>
<DT><A NAME="label:26">spi_prepare(string, [array])</A>
<DD>
<P>
Prepares AND SAVES a query plan for later execution. It is a bit
different from the C level SPI_prepare in that the plan is
automatically copied to the toplevel memory context. Thus, there is
currently no way of preparing a plan without saving it.
</P>

<P>
If the query references arguments, the type names must be given as a
Ruby array of strings. The return value from prepare is a
<KBD>PLrubyplan</KBD> object to be used in subsequent calls to
<KBD>PLrubyplan#exec</KBD>.
</P>
</DD>
</DL>
<H3><A NAME="label:8">class PLrubyplan</A></H3>
<DL>
<DT><A NAME="label:30">exec(values, [count])</A>
<DT><A NAME="label:31">execp(values, [count])</A>
<DD>
<P>
Execute a prepared plan from <KBD>PLruby#prepare</KBD> with variable
substitution. The optional <KBD>count</KBD> value tells
<KBD>PLrubyplan#exec</KBD> the maximum number of rows to be processed by the
query.
</P>

<P>
If there was a typelist given to <KBD>PLruby#prepare</KBD>, an array
of <KBD>values</KBD> of exactly the same length must be given to
<KBD>PLrubyplan#exec</KBD> as first argument. If the type list on
<KBD>PLruby#prepare</KBD> was empty, this argument must be omitted.
</P>

<P>
If the query is a SELECT statement, the same as described for
<KBD>PLruby#exec</KBD> happens for the loop-body and the variables for
the fields selected.
</P>

<P>
Here's an example for a PL/Ruby function using a prepared plan : 
</P>

<BLOCKQUOTE><PRE>
CREATE FUNCTION t1_count(int4, int4) RETURNS int4 AS '
    if ! $Plans.key?("plan")
        # prepare the saved plan on the first call
        $Plans["plan"] = PLruby.prepare("SELECT count(*) AS cnt FROM t1 
                                          WHERE num &gt;= $1 AND num &lt;= $2",
                                         ["int4", "int4"])
    end
    n = $Plans["plan"].exec([args[0], args[1]], 1)
    n["cnt"]
' LANGUAGE 'plruby';



</PRE></BLOCKQUOTE>
</DD>
</DL>

</BODY>
</HTML>