<?xml version="1.0" ?>
<!DOCTYPE html 
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Untitled</title>
</head>
<body>
<h1><a name="label-0" id="label-0">PL/Ruby</a></h1><!-- RDLabel: "PL/Ruby" -->
<ul>
<li><a href="#label-2">Defining function in PL Ruby</a></li>
<li><a href="#label-4">Function returning SET</a></li>
<li><a href="#label-5">Trigger procedures in PL Ruby</a></li>
<li><a href="#label-17">plruby_singleton_methods</a></li>
<li><a href="#label-18">Class and modules</a></li>
</ul>
<p>PL/Ruby is a loadable procedural language for the Postgres database
system  that enable the Ruby language to create functions and trigger
procedures</p>
<p>Functions and triggers are singleton methods of the module PLtemp.</p>
<h1><a name="label-1" id="label-1">WARNING</a></h1><!-- RDLabel: "WARNING" -->
<p><em>All arguments (to the function or the triggers) are passed as string 
values, except for NULL values represented by <kbd>Qnil</kbd>.</em>
<em>You must explicitely call a conversion function (like to_i) if you want 
to use an argument as an integer</em></p>
<h2><a name="label-2" id="label-2">Defining function in PL Ruby</a></h2><!-- RDLabel: "Defining function in PL Ruby" -->
<p>To create a function in the PL/Ruby language use the syntax</p>
<pre>CREATE FUNCTION funcname(arguments_type) RETURNS type AS '

 # PL/Ruby function body

' LANGUAGE 'plruby';</pre>
<p>when calling the function in a query, the arguments are given <em>as
string values</em> in the array <kbd>args</kbd>. To create a little max
function returning the higher of two int4 values write :</p>
<pre>CREATE FUNCTION ruby_max(int4, int4) RETURNS int4 AS '
    if args[0].to_i &gt; args[1].to_i
        return args[0]
    else
        return args[1]
    end
' LANGUAGE 'plruby';</pre>
<p>Tuple arguments are given as hash. Here is an example that defines
the overpaid_2 function (as found in the older Postgres documentation)
in PL/Ruby.</p>
<pre>CREATE FUNCTION overpaid_2 (EMP) RETURNS bool AS '
    args[0]["salary"].to_f &gt; 200000 || 
       (args[0]["salary"].to_f &gt; 100000 &amp;&amp; args[0]["age"].to_i &lt; 30)
' LANGUAGE 'plruby';</pre>
<h3><a name="label-3" id="label-3">Warning : with PostgreSQL &gt;= 7.4 "array" are given as a ruby Array</a></h3><!-- RDLabel: "Warning : with PostgreSQL >= 7.4 "array" are given as a ruby Array" -->
<p>For example to define a function (int4[], int4) and return int4[],
in version &lt; 7.4 you write</p>
<pre>CREATE FUNCTION ruby_int4_accum(_int4, int4) RETURNS _int4 AS '
    if /\\{(\\d+),(\\d+)\\}/ =~ args[0]
        a, b = $1, $2
        newsum = a.to_i + args[1].to_i
        newcnt = b.to_i + 1
    else
        raise "unexpected value #{args[0]}"
    end
    "{#{newsum},#{newcnt}}"
' LANGUAGE 'plruby';</pre>
<p>This must now (&gt;= 7.4) be written</p>
<pre>CREATE FUNCTION ruby_int4_accum(_int4, int4) RETURNS _int4 AS '
   a = args[0]
   [a[0].to_i + args[1].to_i, a[1].to_i + 1]
' LANGUAGE 'plruby';</pre>
<h2><a name="label-4" id="label-4">Function returning SET</a></h2><!-- RDLabel: "Function returning SET" -->
<p>The return type must be declared as SETOF</p>
<p>The function must call <kbd>yield</kbd> to return rows or return a String which
must be a valid SELECT statement</p>
<p>For example to concatenate 2 rows create the function</p>
<pre>plruby_test=# CREATE FUNCTION tu(varchar) RETURNS setof record
plruby_test-# AS '
plruby_test'#    size = PL.column_name(args[0]).size
plruby_test'#    res = nil
plruby_test'#    PL::Plan.new("select * from #{args[0]}", 
plruby_test'#                 "block" =&gt; 50).each do |row|
plruby_test'#       if res.nil?
plruby_test'#          res = row.values
plruby_test'#       else
plruby_test'#          res.concat row.values
plruby_test'#          yield res
plruby_test'#          res = nil
plruby_test'#       end
plruby_test'#    end
plruby_test'#    if res
plruby_test'#       res.concat Array.new(size)
plruby_test'#       yield res
plruby_test'#    end
plruby_test'# ' language 'plruby';
CREATE FUNCTION
plruby_test=# 
plruby_test=# select * from tt;
 a | b  
---+----
 1 |  2
 3 |  4
 5 |  6
 7 |  8
 9 | 10
(5 rows)

plruby_test=# select * from tu('tt') as tbl(a int, b int, c int, d int);
 a | b  | c | d 
---+----+---+---
 1 |  2 | 3 | 4
 5 |  6 | 7 | 8
 9 | 10 |   |  
(3 rows)

plruby_test=# </pre>
<h2><a name="label-5" id="label-5">Trigger procedures in PL Ruby</a></h2><!-- RDLabel: "Trigger procedures in PL Ruby" -->
<p>Trigger procedures are defined in Postgres as functions without
arguments and a return type of trigger. In PL/Ruby the procedure is
called with 4 arguments :</p>
<dl>
<dt><a name="label-6" id="label-6">new (hash, tainted)</a></dt><!-- RDLabel: "new (hash, tainted)" -->
<dd>
an hash containing the values of the new table row on INSERT/UPDATE
actions, or empty on DELETE. 
</dd>
<dt><a name="label-7" id="label-7">old (hash, tainted)</a></dt><!-- RDLabel: "old (hash, tainted)" -->
<dd>
an hash containing the values of the old table row on UPDATE/DELETE
actions, or empty on INSERT 
</dd>
<dt><a name="label-8" id="label-8">args (array, tainted, frozen)</a></dt><!-- RDLabel: "args (array, tainted, frozen)" -->
<dd>
An array of the arguments to the procedure as given in the CREATE
TRIGGER statement 
</dd>
<dt><a name="label-9" id="label-9">tg (hash, tainted, frozen)</a></dt><!-- RDLabel: "tg (hash, tainted, frozen)" -->
<dd>
The following keys are defined
<dl>
<dt><a name="label-10" id="label-10">name</a></dt><!-- RDLabel: "name" -->
<dd>
The name of the trigger from the CREATE TRIGGER statement.
</dd>
<dt><a name="label-11" id="label-11">relname</a></dt><!-- RDLabel: "relname" -->
<dd>
The name of the relation who has fired the trigger
</dd>
<dt><a name="label-12" id="label-12">relid</a></dt><!-- RDLabel: "relid" -->
<dd>
The object ID of the table that caused the trigger procedure to be invoked.
</dd>
<dt><a name="label-13" id="label-13">relatts</a></dt><!-- RDLabel: "relatts" -->
<dd>
An array containing the name of the tables field.
</dd>
<dt><a name="label-14" id="label-14">when</a></dt><!-- RDLabel: "when" -->
<dd>
The constant <kbd>PL::BEFORE</kbd>, <kbd>PL::AFTER</kbd> or
<kbd>PL::UNKNOWN</kbd> depending on the event of the trigger call.
</dd>
<dt><a name="label-15" id="label-15">level</a></dt><!-- RDLabel: "level" -->
<dd>
The constant <kbd>PL::ROW</kbd> or <kbd>PL::STATEMENT</kbd>
depending on the event of the trigger call.
</dd>
<dt><a name="label-16" id="label-16">op</a></dt><!-- RDLabel: "op" -->
<dd>
The constant <kbd>PL::INSERT</kbd>, <kbd>PL::UPDATE</kbd> or 
<kbd>PL::DELETE</kbd> depending on the event of the trigger call.
</dd>
</dl>
</dd>
</dl>
<p>The return value from a trigger procedure is one of the constant
<kbd>PL::OK</kbd> or <kbd>PL::SKIP</kbd>, or an hash. If the
return value is <kbd>PL::OK</kbd>, the normal operation
(INSERT/UPDATE/DELETE) that fired this trigger will take
place. Obviously, <kbd>PL::SKIP</kbd> tells the trigger manager to
silently suppress the operation. The hash tells
PL/Ruby to return a modified row to the trigger manager that will be
inserted instead of the one given in <kbd>new</kbd> (INSERT/UPDATE
only). Needless to say that all this is only meaningful when the
trigger is BEFORE and FOR EACH ROW.</p>
<p>Here's a little example trigger procedure that forces an integer
value in a table to keep track of the # of updates that are performed
on the row. For new row's inserted, the value is initialized to 0 and
then incremented on every update operation :</p>
<pre>CREATE FUNCTION trigfunc_modcount() RETURNS TRIGGER AS '
    case tg["op"]
    when PL::INSERT
        new[args[0]] = 0
      when PL::UPDATE
          new[args[0]] = old[args[0]].to_i + 1
      else
          return PL::OK
      end
      new
  ' LANGUAGE 'plruby';

  CREATE TABLE mytab (num int4, modcnt int4, descr text);

  CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab
      FOR EACH ROW EXECUTE PROCEDURE trigfunc_modcount('modcnt');</pre>
<p>A more complex example (extract from test_setup.sql in the distribution)
which use the global variable <kbd>$Plans</kbd> to store a prepared
plan</p>
<pre>create function trig_pkey2_after() returns trigger as '
   if ! $Plans.key?("plan_dta2_upd")
       $Plans["plan_dta2_upd"] = 
            PL::Plan.new("update T_dta2 
                          set ref1 = $3, ref2 = $4
                          where ref1 = $1 and ref2 = $2",
                         ["int4", "varchar", "int4", "varchar" ]).save
       $Plans["plan_dta2_del"] = 
            PL::Plan.new("delete from T_dta2 
                          where ref1 = $1 and ref2 = $2", 
                         ["int4", "varchar"]).save
   end

   old_ref_follow = false
   old_ref_delete = false

   case tg["op"]
   when PL::UPDATE
       new["key2"] = new["key2"].upcase
       old_ref_follow = (new["key1"] != old["key1"]) || 
                        (new["key2"] != old["key2"])
   when PL::DELETE
       old_ref_delete = true
   end

   if old_ref_follow
       n = $Plans["plan_dta2_upd"].exec([old["key1"], old["key2"], new["key1"],
new["key2"]])
       warn "updated #{n} entries in T_dta2 for new key in T_pkey2" if n != 0
   end

   if old_ref_delete
       n = $Plans["plan_dta2_del"].exec([old["key1"], old["key2"]])
       warn "deleted #{n} entries from T_dta2" if n != 0
   end

   PL::OK
' language 'plruby';

create trigger pkey2_after after update or delete on T_pkey2
 for each row execute procedure
 trig_pkey2_after();</pre>
<h2><a name="label-17" id="label-17">plruby_singleton_methods</a></h2><!-- RDLabel: "plruby_singleton_methods" -->
<p>Sometime it can be usefull to define methods (in pure Ruby) which can be
called from a PL/Ruby function or a PL/Ruby trigger.</p>
<p>In this case, you have 2 possibilities</p>
<ul>
<li>the "stupid" way <code>:-) :-) :-)</code></li>
</ul>
<p>just close the current definition of the function (or trigger) with a
<code>end</code> and define your singleton method without the final <code>end</code></p>
<p>Here a small and useless example</p>
<pre>toto=&gt; CREATE FUNCTION tutu() RETURNS int4 AS '
toto'&gt;     toto(1, 3) + toto(4, 4)
toto'&gt; end
toto'&gt; 
toto'&gt; def PLtemp.toto(a, b)
toto'&gt;     a + b
toto'&gt; ' LANGUAGE 'plruby';
CREATE
toto=&gt; select tutu();
tutu
----
  12
(1 row)

toto=&gt;</pre>
<ul>
<li>create a table plruby_singleton_methods with the columns (name, args, body)</li>
</ul>
<p>At load time, PL/Ruby look if it exist a table plruby_singleton_methods and if
found try, for each row, to define singleton methods with the template :</p>
<pre>def PLtemp.#{name} (#{args})
    #{body}
end</pre>
<p>The previous example can be written (you have a more complete example in
test/plp/test_setup.sql)</p>
<pre>toto=&gt; SELECT * FROM plruby_singleton_methods;
name|args|body 
----+----+-----
toto|a, b|a + b
(1 row)

toto=&gt; CREATE FUNCTION tutu() RETURNS int4 AS '
toto'&gt;     toto(1, 3) + toto(4, 4)
toto'&gt; ' LANGUAGE 'plruby';
CREATE
toto=&gt; select tutu();
tutu
----
  12
(1 row)

toto=&gt;</pre>
<h2><a name="label-18" id="label-18">Class and modules</a></h2><!-- RDLabel: "Class and modules" -->
<h3><a name="label-19" id="label-19">Global</a></h3><!-- RDLabel: "Global" -->
<dl>
<dt><a name="label-20" id="label-20"><code>warn [<var>level</var>], <var>message</var></code></a></dt><!-- RDLabel: "warn [level], message" -->
<dd>
<p>Ruby interface to PostgreSQL elog()</p>
<p>Possible value for <kbd>level</kbd> are <kbd>NOTICE</kbd>, <kbd>DEBUG</kbd> and <kbd>NOIND</kbd></p>
<p>Use <kbd>raise()</kbd> if you want to simulate <kbd>elog(ERROR, "...")</kbd></p></dd>
<dt><a name="label-21" id="label-21"><code>$Plans (<var>hash</var>, <var>tainted</var>)</code></a></dt><!-- RDLabel: "$Plans" -->
<dd>
can be used to store prepared plans.</dd>
</dl>
<h3><a name="label-22" id="label-22">module PL</a></h3><!-- RDLabel: "module PL" -->
<dl>
<dt><a name="label-23" id="label-23"><code>args_type</code></a></dt><!-- RDLabel: "args_type" -->
<dd>
Return the type of the arguments given to the function</dd>
<dt><a name="label-24" id="label-24"><code>column_name(<var>table</var>)</code></a></dt><!-- RDLabel: "column_name" -->
<dd>
Return the name of the columns for the table</dd>
<dt><a name="label-25" id="label-25"><code>column_type(<var>table</var>)</code></a></dt><!-- RDLabel: "column_type" -->
<dd>
return the type of the columns for the table</dd>
<dt><a name="label-26" id="label-26"><code>quote(<var>string</var>)</code></a></dt><!-- RDLabel: "quote" -->
<dd>
Duplicates all occurences of single quote and backslash
characters. It should be used when variables are used in the query
string given to spi_exec or spi_prepare (not for the value list on
execp).</dd>
<dt><a name="label-27" id="label-27"><code>result_name</code></a></dt><!-- RDLabel: "result_name" -->
<dd>
Return the name of the columns for a function returning a SETOF</dd>
<dt><a name="label-28" id="label-28"><code>result_type</code></a></dt><!-- RDLabel: "result_type" -->
<dd>
Return the type of the columns for a function returning a SETOF
or the type of the return value</dd>
<dt><a name="label-29" id="label-29"><code>result_size</code></a></dt><!-- RDLabel: "result_size" -->
<dd>
Return the number of columns  for a function returning a SETOF</dd>
<dt><a name="label-30" id="label-30"><code>result_description</code></a></dt><!-- RDLabel: "result_description" -->
<dd>
Return the table description given to a function returning a SETOF</dd>
<dt><a name="label-31" id="label-31"><code>exec(<var>string</var> [, <var>count</var> [, <var>type</var>]])</code></a></dt><!-- RDLabel: "exec" -->
<dt><a name="label-32" id="label-32"><code>spi_exec(<var>string</var> [, <var>count</var> [, <var>type</var>]])</code></a></dt><!-- RDLabel: "spi_exec" -->
<dd>
Call parser/planner/optimizer/executor for query. The optional
<kbd>count</kbd> value tells spi_exec the maximum number of rows to be
processed by the query.
<dl>
<dt><a name="label-33" id="label-33">SELECT</a></dt><!-- RDLabel: "SELECT" -->
<dd>
<p>If the query is a SELECT statement, an array is return (if count is
not specified or with a value &gt; 1). Each element of this array is an
hash where the key is the column name.  For example this procedure
display all rows in the table pg_table.</p>
<pre>CREATE FUNCTION pg_table_dis() RETURNS int4 AS '
res = PLruby.exec("select * from pg_class")
res.each do |x|
    warn "======================"
    x.each do |y, z|
        warn "name = #{y} -- value = #{z}"
    end
    warn "======================"
end
return res.size
' LANGUAGE 'plruby';</pre>
<p>if type is specified it can take the value</p>
<ul>
<li>"array" return an array with the element ["name", "value", "type", "len", "typeid"]</li>
<li>"hash" return an hash with the keys {"name", "value", "type", "len", "typeid"}</li>
</ul>
<pre>Example :

create table T_pkey1 (
    skey1        int4,
    skey2        varchar(20),
    stxt         varchar(40)
);

create function toto() returns bool as '
   warn("=======")
   PL.exec("select * from T_pkey1", 1, "hash") do |a|
      warn(a.inspect)
   end
   warn("=======")
   PL.exec("select * from T_pkey1", 1, "array") do |a|
      warn(a.inspect)
   end
   warn("=======")
   PL.exec("select * from T_pkey1", 1) do |a|
      warn(a.inspect)
   end
   warn("=======")
   return true
' language 'plruby';


plruby_test=# select toto();
NOTICE:  =======
NOTICE:  {"name"=&gt;"skey1", "typeid"=&gt;23, "type"=&gt;"int4", "value"=&gt;"12", "len"=&gt;4}
NOTICE:  {"name"=&gt;"skey2", "typeid"=&gt;1043, "type"=&gt;"varchar", "value"=&gt;"a", "len"=&gt;20}
NOTICE:  {"name"=&gt;"stxt", "typeid"=&gt;1043, "type"=&gt;"varchar", "value"=&gt;"b", "len"=&gt;40}
NOTICE:  =======
NOTICE:  ["skey1", "12", "int4", 4, 23]
NOTICE:  ["skey2", "a", "varchar", 20, 1043]
NOTICE:  ["stxt", "b", "varchar", 40, 1043]
NOTICE:  =======
NOTICE:  ["skey1", "12"]
NOTICE:  ["skey2", "a"]
NOTICE:  ["stxt", "b"]
NOTICE:  =======
 toto 
------
 t
(1 row)

plruby_test=# </pre>
<p>A block can be specified, in this case a call to yield() will be
made.</p>
<p>If count is specified with the value 1, only the first row (or
FALSE if it fail) is returned as a hash. Here a little example :</p>
<pre>CREATE FUNCTION pg_table_dis() RETURNS int4 AS '
   PL.exec("select * from pg_class", 1) { |y, z|
      warn "name = #{y} -- value = #{z}"
  }
  return 1
' LANGUAGE 'plruby';</pre>
</dd>
<dt><a name="label-34" id="label-34">SELECT INTO, INSERT, UPDATE, DELETE</a></dt><!-- RDLabel: "SELECT INTO, INSERT, UPDATE, DELETE" -->
<dd>
return the number of rows insered, updated, deleted, ...
</dd>
<dt><a name="label-35" id="label-35">UTILITY</a></dt><!-- RDLabel: "UTILITY" -->
<dd>
return TRUE
</dd>
</dl></dd>
<dt><a name="label-36" id="label-36"><code>prepare(<var>string</var>[, <var>types</var>])</code></a></dt><!-- RDLabel: "prepare" -->
<dt><a name="label-37" id="label-37"><code>spi_prepare(<var>string</var>[, <var>types</var>])</code></a></dt><!-- RDLabel: "spi_prepare" -->
<dt><a name="label-38" id="label-38"><code>prepare(<var>string</var>, "<var>types</var>" =&gt; <var>types</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>, "<var>tmp</var>" =&gt; <var>true</var>)</code></a></dt><!-- RDLabel: "prepare" -->
<dd>
<p>Deprecated : See <kbd>PL::Plan::new</kbd> and <kbd>PL::Plan#save</kbd></p>
<p>Prepares AND SAVES a query plan for later execution. It is a bit
different from the C level SPI_prepare in that the plan is
automatically copied to the toplevel memory context.</p>
<p>If the query references arguments, the type names must be given as a
Ruby array of strings. The return value from prepare is a
<kbd>PL::Plan</kbd> object to be used in subsequent calls to
<kbd>PL::Plan#exec</kbd>.</p>
<p>If the hash given has the keys <kbd>count</kbd>, <kbd>output</kbd> these values
will be given to the subsequent calls to <kbd>each</kbd></p></dd>
</dl>
<h3><a name="label-39" id="label-39">class PL::Plan</a></h3><!-- RDLabel: "class PL::Plan" -->
<dl>
<dt><a name="label-40" id="label-40"><code>initialize(<var>string</var>, "<var>types</var>" =&gt; <var>types</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>, "<var>save</var>" =&gt; <var>false</var>)</code></a></dt><!-- RDLabel: "initialize" -->
<dd>
<p>Prepares a query plan for later execution.</p>
<p>If the query references arguments, the type names must be given as a
Ruby array of strings.</p>
<p>If the hash given has the keys <kbd>output</kbd>, <kbd>count</kbd> these values
will be given to the subsequent calls to <kbd>each</kbd></p>
<p>If <kbd>"save"</kbd> as a true value, the plan will be saved </p></dd>
<dt><a name="label-41" id="label-41"><code>exec(<var>values</var>, [<var>count</var> [, <var>type</var>]])</code></a></dt><!-- RDLabel: "exec" -->
<dt><a name="label-42" id="label-42"><code>execp(<var>values</var>, [<var>count</var> [, <var>type</var>]])</code></a></dt><!-- RDLabel: "execp" -->
<dt><a name="label-43" id="label-43"><code>exec("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>)</code></a></dt><!-- RDLabel: "exec" -->
<dt><a name="label-44" id="label-44"><code>execp("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>)</code></a></dt><!-- RDLabel: "execp" -->
<dd>
<p>Execute a prepared plan from <kbd>PL::PLan::new</kbd> with variable
substitution. The optional <kbd>count</kbd> value tells
<kbd>PL::Plan#exec</kbd> the maximum number of rows to be processed by the
query.</p>
<p>If there was a typelist given to <kbd>PL::Plan::new</kbd>, an array
of <kbd>values</kbd> of exactly the same length must be given to
<kbd>PL::Plan#exec</kbd> as first argument. If the type list on
<kbd>PL::Plan::new</kbd> was empty, this argument must be omitted.</p>
<p>If the query is a SELECT statement, the same as described for
<kbd>PL#exec</kbd> happens for the loop-body and the variables for
the fields selected.</p>
<p>If type is specified it can take the values</p>
<ul>
<li>"array" return an array with the element ["name", "value", "type", "len", "typeid"]</li>
<li>"hash" return an hash with the keys {"name", "value", "type", "len", "typeid"}</li>
<li>"value" return an array with all values</li>
</ul>
<p>Here's an example for a PL/Ruby function using a prepared plan : </p>
<pre>CREATE FUNCTION t1_count(int4, int4) RETURNS int4 AS '
    if ! $Plans.key?("plan")
        # prepare the saved plan on the first call
        $Plans["plan"] = PL::Plan.new("SELECT count(*) AS cnt FROM t1 
                                       WHERE num &gt;= $1 AND num &lt;= $2",
                                      ["int4", "int4"]).save
    end
    n = $Plans["plan"].exec([args[0], args[1]], 1)
    n["cnt"]
' LANGUAGE 'plruby';</pre></dd>
<dt><a name="label-45" id="label-45"><code>cursor(<var>name</var> = <var>nil</var>, "<var>values</var>" =&gt; <var>values</var>, "<var>output</var>" =&gt; <var>type</var>)</code></a></dt><!-- RDLabel: "cursor" -->
<dd>
<p>Create a new object PL::Cursor</p>
<p>If output is specified it can take the values</p>
<ul>
<li>"array" return an array with the element ["name", "value", "type", "len", "typeid"]</li>
<li>"hash" return an hash with the keys {"name", "value", "type", "len", "typeid"}</li>
<li>"value" return an array with all values</li>
</ul>
<p>If there was a typelist given to <kbd>PL::Plan::new</kbd>, an array
of <kbd>values</kbd> of exactly the same length must be given to
<kbd>PL::Plan#cursor</kbd></p></dd>
<dt><a name="label-46" id="label-46"><code>each(<var>values</var>, [<var>count</var> [, <var>type</var> ]]) { ... }</code></a></dt><!-- RDLabel: "each" -->
<dt><a name="label-47" id="label-47"><code>fetch(<var>values</var>, [<var>count</var> [, <var>type</var> ]]) { ... }</code></a></dt><!-- RDLabel: "fetch" -->
<dt><a name="label-48" id="label-48"><code>each("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>) { ... }</code></a></dt><!-- RDLabel: "each" -->
<dt><a name="label-49" id="label-49"><code>fetch("<var>values</var>" =&gt; <var>values</var>, "<var>count</var>" =&gt; <var>count</var>, "<var>output</var>" =&gt; <var>type</var>) { ... }</code></a></dt><!-- RDLabel: "fetch" -->
<dd>
<p>Same then #exec but a call to SPI_cursor_open(), SPI_cursor_fetch() is made.</p>
<p>Can be used only with a block and a SELECT statement</p>
<pre>create function toto() returns bool as '
       plan = PL::Plan.new("select * from T_pkey1")
       warn "=====&gt; ALL"
       plan.each do |x|
          warn(x.inspect)
       end
       warn "=====&gt; FIRST 2"
       plan.each("count" =&gt; 2) do |x|
          warn(x.inspect)
       end
       return true
' language 'plruby';

plruby_test=# select * from T_pkey1;
 skey1 | skey2 | stxt 
-------+-------+------
    12 | a     | b
    24 | c     | d
    36 | e     | f
(3 rows)

plruby_test=# 
plruby_test=# select toto();
NOTICE:  =====&gt; ALL
NOTICE:  {"skey1"=&gt;"12", "skey2"=&gt;"a", "stxt"=&gt;"b"}
NOTICE:  {"skey1"=&gt;"24", "skey2"=&gt;"c", "stxt"=&gt;"d"}
NOTICE:  {"skey1"=&gt;"36", "skey2"=&gt;"e", "stxt"=&gt;"f"}
NOTICE:  =====&gt; FIRST 2
NOTICE:  {"skey1"=&gt;"12", "skey2"=&gt;"a", "stxt"=&gt;"b"}
NOTICE:  {"skey1"=&gt;"24", "skey2"=&gt;"c", "stxt"=&gt;"d"}
 toto 
------
 t
(1 row)

plruby_test=# </pre></dd>
<dt><a name="label-50" id="label-50"><code>release</code></a></dt><!-- RDLabel: "release" -->
<dd>
Release a query plan</dd>
<dt><a name="label-51" id="label-51"><code>save</code></a></dt><!-- RDLabel: "save" -->
<dd>
Save a query plan for later execution. The plan is copied to the
toplevel memory context.</dd>
</dl>
<h3><a name="label-52" id="label-52">class PL::Cursor</a></h3><!-- RDLabel: "class PL::Cursor" -->
<dl>
<dt><a name="label-53" id="label-53"><code>close</code></a></dt><!-- RDLabel: "close" -->
<dd>
Closes a cursor</dd>
<dt><a name="label-54" id="label-54"><code>each {|<var>row</var>| ... }</code></a></dt><!-- RDLabel: "each" -->
<dd>
Iterate over all rows (forward)</dd>
<dt><a name="label-55" id="label-55"><code>fetch(<var>count</var> = <var>1</var>)</code></a></dt><!-- RDLabel: "fetch" -->
<dt><a name="label-56" id="label-56"><code>row(<var>count</var> = <var>1</var>)</code></a></dt><!-- RDLabel: "row" -->
<dd>
<p>Fetches some rows from a cursor</p>
<p>if count &gt; 0 fetch forward else backward</p></dd>
<dt><a name="label-57" id="label-57"><code>move(<var>count</var>)</code></a></dt><!-- RDLabel: "move" -->
<dd>
Move a cursor : if count &gt; 0 move forward else backward</dd>
<dt><a name="label-58" id="label-58"><code>reverse_each {|<var>row</var>| ... }</code></a></dt><!-- RDLabel: "reverse_each" -->
<dd>
Iterate over all rows (backward)</dd>
<dt><a name="label-59" id="label-59"><code>rewind</code></a></dt><!-- RDLabel: "rewind" -->
<dd>
Positions the cursor at the beginning of the table</dd>
</dl>

</body>
</html>
